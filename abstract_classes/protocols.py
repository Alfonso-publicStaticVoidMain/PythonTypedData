from __future__ import annotations

import sys
from typing import Protocol, Iterable, Sized, Container, Iterator, Any, SupportsIndex


class CollectionProtocol[T](Protocol, Iterable[T], Sized, Container[T]):
    def __len__(self) -> int: ...
    def __iter__(self) -> Iterator[T]: ...
    def __contains__(self, item: object) -> bool: ...
    def __eq__(self, other) -> bool: ...


class MutableCollectionProtocol[T](CollectionProtocol[T]):
    def remove(self, item: object) -> None: ...
    def clear(self) -> None: ...


class Comparable(Protocol):
    def __lt__(self, other) -> bool: ...
    def __le__(self, other) -> bool: ...
    def __gt__(self, other) -> bool: ...
    def __ge__(self, other) -> bool: ...


class LogicalOrAndXor(Protocol):
    def __or__(self, other) -> LogicalOrAndXor: ...
    def __and__(self, other) -> LogicalOrAndXor: ...
    def __xor__(self, other) -> LogicalOrAndXor: ...


class SequenceProtocol[T](CollectionProtocol[T], Comparable):
    def __getitem__(self, index: SupportsIndex | slice) -> T: ...
    def __add__(self, other) -> SequenceProtocol[T]: ...
    def __mul__(self, n: int) -> SequenceProtocol[T]: ...
    def __rmul__(self, n: int) -> SequenceProtocol[T]: ...
    def __reversed__(self) -> Iterator[T]: ...
    def index(self, value: Any, start: SupportsIndex = 0, stop: SupportsIndex = sys.maxsize) -> int: ...


class MutableSequenceProtocol[T](SequenceProtocol[T], MutableCollectionProtocol[T]):
    def __setitem__(self, index: SupportsIndex | slice, value: T) -> None: ...
    def __delitem__(self, index: SupportsIndex | slice) -> None: ...
    def append(self, obj: T) -> None: ...
    def extend(self, iterable: Iterable[T]) -> None: ...
    def sort(self: MutableSequenceProtocol[T], *, key: None = None, reverse: bool = False) -> None: ...
    def reverse(self) -> None: ...
    def insert(self, index: SupportsIndex, obj: T) -> None: ...
    def pop(self, index: SupportsIndex) -> T: ...


class SetProtocol[T](CollectionProtocol[T], Comparable, LogicalOrAndXor):
    def union[S](self, *s: Iterable[S]) -> SetProtocol[T | S]: ...
    def intersection(self, *s: Iterable[object]) -> SetProtocol[T]: ...
    def difference(self, *s: Iterable[object]) -> SetProtocol[T]: ...
    def symmetric_difference(self, s: Iterable[object]) -> SetProtocol[T]: ...
    def issubset(self, s: Iterable[object]) -> bool: ...
    def issuperset(self, s: Iterable[object]) -> bool: ...
    def isdisjoint(self, s: Iterable[object]) -> bool: ...


class MutableSetProtocol[T](SetProtocol[T], MutableCollectionProtocol[T]):
    def add(self, element: T) -> None: ...
    def discard(self, element: T) -> None: ...
    def update(self, *s: Iterable[T]) -> None: ...
    def difference_update(self, *s: Iterable[Any]) -> None: ...
    def intersection_update(self, *s: Iterable[Any]) -> None: ...
    def symmetric_difference_update(self, s: Iterable[T]) -> None: ...


class DictProtocol[K, V](LogicalOrAndXor, Protocol, Iterable[K], Sized, Container[K]):
    def __len__(self) -> int: ...
    def __iter__(self) -> Iterator[K]: ...
    def __contains__(self, item: object) -> bool: ...
    def __eq__(self, other) -> bool: ...
    def __getitem__(self, item: K) -> V: ...
    def keys(self): ...
    def values(self): ...
    def items(self): ...


class MutableDictProtocol[K, V](DictProtocol[K, V]):
    def __setitem__(self, key, value) -> None: ...
    def __delitem__(self, key) -> None: ...
    def clear(self) -> None: ...
    def pop(self, key: K, fallback: V) -> V: ...
    def popitem(self) -> tuple[K, V]: ...
    def setdefault(self: MutableDictProtocol[K, V], key: K, default: None = None, /) -> V | None: ...
